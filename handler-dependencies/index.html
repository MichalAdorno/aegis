<!doctype html>
<html>
<head>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-295433-8"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-295433-8');
    </script>

    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Handler-dependencies</title>
    <link href='/aegis/slate/stylesheets/monokai.css' rel="stylesheet" media="screen" />
<link href='/aegis/slate/stylesheets/screen.css' rel="stylesheet" media="screen" />
<link href='/aegis/slate/stylesheets/print.css' rel="stylesheet" media="print" />

    <link href='/aegis/css/styles.css' rel="stylesheet"/>
    <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.0.13/css/solid.css" integrity="sha384-drdlAcijFWubhOfj9OS/gy2Gs34hVhVT90FgJLzrldrLI+7E7lwBxmanEEhKTRTS" crossorigin="anonymous">
<link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.0.13/css/fontawesome.css" integrity="sha384-LDuQaX4rOgqi4rbWCyWj3XVBlgDzuxGy/E6vWN6U7c25/eSJIwyKhy9WgZCHQWXz" crossorigin="anonymous">
    
<script src='/aegis/slate/javascripts/all.js'></script>

    
</head>
<body class="index" data-languages="">
    <div class="main-nav-wrapper">
        <ul class="main-menu">
            <li class="">
    <a href="/aegis/">Getting Started</a>
</li>


    
    <li class="">
        <a href="/aegis/routers/" title="Aegis Routers">Routers</a>
    </li>
    

    
    <li class="active">
        <a href="/aegis/handler-dependencies/" title="Aegis Dependencies">Dependencies</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/helpers/" title="Aegis Helpers">Helpers</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/cli/" title="Aegis Command Line Interface">CLI</a>
    </li>
    

        </ul>
    </div>
    <a href="#" id="nav-button">
        <span>
        NAV
        <img src='/aegis/slate/images/navbar.png'/>
      </span>
    </a>
    <div class="tocify-wrapper">
        
         
 <div id="logo-type">
    <h1 class="toc-ignore">Aegis</h1>
    <h2 class="toc-ignore">An AWS Serverless Framework for Go</h2>
</div>
         
        <aside class="main-menu-sidebar-wrapper">
    <ul class="main-menu-sidebar">
        <li class="">
    <a href="/aegis/">Getting Started</a>
</li>


    
    <li class="">
        <a href="/aegis/routers/" title="Aegis Routers">Routers</a>
    </li>
    

    
    <li class="active">
        <a href="/aegis/handler-dependencies/" title="Aegis Dependencies">Dependencies</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/helpers/" title="Aegis Helpers">Helpers</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/cli/" title="Aegis Command Line Interface">CLI</a>
    </li>
    

    </ul>
</aside>
        
        <div class="search">
            <input type="text" class="search" id="input-search" placeholder='Search This Section'>
        </div>
        <ul class="search-results"></ul>
        
        <div id="toc">
        </div>
         
        
        <ul class="toc-footer">
            
            <li>Hugo Theme by <a href="https://github.com/bep" target="_blank">bep</a></li>
            
        </ul>
        
        
    </div>
    <div class="page-wrapper">
        <div class="dark-box"></div>
        <div class="content">
            
    
        <h1 class="toc-ignore">Handler Dependencies</h1>

<p>Handlers need a variety of services and dependencies in order to make life easier. It&rsquo;s a very big
part of why one reaches for a framework. The idea of &ldquo;dependency injection&rdquo; is the foundation of many
frameworks and Aegis isn&rsquo;t much different.</p>

<p>Really, routing events to handlers is the foundation of Aegis, but you can&rsquo;t abstract that away without
being able to pass along functionality required by each handler.</p>

<p>Aegis has a few core dependencies that even its internal handler (a handler before your handler)
uses and passes along for you to use as well. Also, you can also pass along your own dependencies
if you need to.</p>

    
        

<h1 id="log">Log</h1>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">logger</span> <span class="o">:=</span> <span class="nx">logrus</span><span class="p">.</span><span class="nx">New</span><span class="p">()</span>
<span class="c1">// Various configuration options for logrus...
</span><span class="c1"></span>
<span class="nx">AegisApp</span> <span class="p">=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">handlers</span><span class="p">)</span>
<span class="c1">// Set your configured logger on Log
</span><span class="c1"></span><span class="nx">AegisApp</span><span class="p">.</span><span class="nx">Log</span> <span class="p">=</span> <span class="nx">logger</span>
<span class="nx">AegisApp</span><span class="p">.</span><span class="nx">Start</span><span class="p">()</span></code></pre></div>
<p>Aegis&rsquo; Log dependency provides an adaptable way to log using the popular Go package
<a href="https://github.com/sirupsen/logrus" target="_blank">logrus</a>.
You&rsquo;re certainly welcome to use the standard library <code>log</code> package as well. AWS Lambda will send all
of that stdout to CloudWatch for you automatically.</p>

<p>However, there may be other logging services you wish to use. Rather than re-invent the wheel, Aegis
used logrus instead because of its adaptability.</p>

<p>Set the <code>Log</code> field on the <code>Aegis</code> interface like any other core dependency to change it. You can
also use the <span class="nowrap"><code>ConfigureLogger(*logrus.Logger)</code></span> helper function.</p>

<p>Do note that everything internally will use <code>log</code>. So anything that Aegis logs out will be found in
CloudWatch. It&rsquo;s not that Aegis didn&rsquo;t want to dogfood its own logging dependency, it&rsquo;s that Aegis
did not want its logging to get in the way of your logging.</p>

<p>For example, if your handler (just one of your Lambdas) wanted to use <code>Log</code> to send information
to your team Slack channel, you wouldn&rsquo;t also want internal Aegis logging to be sent as well. Especially
because you couldn&rsquo;t turn them off. There is currently no sort of verbosity setting in Aegis. If you
were to, say, disable CloudWatch logging for your Lambda altogether then the standard <code>log</code> calls
would simply go no where.</p>

<p>CloudWatch of course isn&rsquo;t the prettiest way to view your logs. While logrus has fancy coloring,
CloudWatch is black and white text through your web browser in the AWS Console. So you might end up
configuring <code>Log</code> in a different way to work with logging in a prettier way.</p>

<p>Another thing worth noting here is that logrus&rsquo; 3rd party formatters can be rather powerful. There are
formatters for things like fluentd, logstash, and more. So you might just find yourself using it for
more than simply basic logging. Also keep in mind that AWS has a hosted version of Elasticsearch with
Kibana&hellip;See where this is going?? You can implement a rather robust searchable logging solution all
within AWS.</p>

    
        

<h1 id="tracer">Tracer</h1>

<blockquote>
<p>How to use a different TraceStrategy</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">AegisApp</span> <span class="p">=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">handlers</span><span class="p">)</span>
<span class="c1">// For example, disabling tracing
</span><span class="c1"></span><span class="nx">AegisApp</span><span class="p">.</span><span class="nx">Tracer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">NoTraceStrategy</span><span class="p">{}</span>
<span class="nx">AegisApp</span><span class="p">.</span><span class="nx">Start</span><span class="p">()</span></code></pre></div>
<blockquote>
<p>How Aegis Router traces internally</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Records data in the tracing strategy. In this case, and by default, X-Ray annotations.
</span><span class="c1"></span><span class="nx">r</span><span class="p">.</span><span class="nx">Tracer</span><span class="p">.</span><span class="nx">Record</span><span class="p">(</span><span class="s">&#34;annotation&#34;</span><span class="p">,</span>
    <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
        <span class="s">&#34;RequestPath&#34;</span><span class="p">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span>
        <span class="s">&#34;Method&#34;</span><span class="p">:</span>      <span class="nx">req</span><span class="p">.</span><span class="nx">HTTPMethod</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">)</span>

<span class="nx">err</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Tracer</span><span class="p">.</span><span class="nx">Capture</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;RouteHandler&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx1</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// Makes the Tracer available inside your handler.
</span><span class="c1"></span>    <span class="c1">// Capture() also applies the annotations from above in the case of XRayTraceStrategy
</span><span class="c1"></span>    <span class="nx">d</span><span class="p">.</span><span class="nx">Tracer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">r</span><span class="p">.</span><span class="nx">Tracer</span>
    <span class="k">return</span> <span class="nx">handler</span><span class="p">.</span><span class="nx">handler</span><span class="p">(</span><span class="nx">ctx1</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">res</span><span class="p">,</span> <span class="nx">params</span><span class="p">)</span>
<span class="p">})</span></code></pre></div>
<p>The <code>Tracer</code> dependency implements a <code>TraceStrategy</code> interface. By default, this is AWS X-Ray
defined as <code>XRayTraceStrategy</code>. There is also <code>NoTraceStrategy</code> available if you&rsquo;d like to disable
tracing (or for unit tests).</p>

<p>However, you can add your own tracing strategy interfaces and use those instead if you wanted to
use something other than X-Ray.</p>

<p>Using a different strategy is as simple as setting the <code>Tracer</code> field on the Aegis interface.
In the examples, this is usually called <code>AegisApp</code>. Do keep in mind that this is a pointer.</p>

<p>Aegis&rsquo; tracing works a little differently than AWS&rsquo; X-Ray. Though you are always free to import
<span class="nowrap"><code>github.com/aws/aws-xray-sdk-go/xray</code></span> to use yourself.</p>

<p>Aegis receives all events in one centralized function and then sends them out to the appropriate
router which in turn calls the matching handler. This is all internal and while there are a few
hooks available, no one wants to use those hooks to run tracing. It&rsquo;s simply not convenient nor
very conventional.</p>

<p>So, Aegis&rsquo; <code>XRayTraceStrategy</code> has some fields, namely; <code>Annotation</code>, <code>NamespaceAnnotation</code>, <code>Metadata</code>,
and <code>Error</code>. These are maps (except <code>Error</code>, a singular error). So we are simply adding to them with
<code>Record()</code> and <code>Capture()</code> will loop through them and add on to the segment in AWS X-Ray. A different
interface implementing <code>TraceStrategy</code> may do something completely different. The <code>NoTraceStrategy</code>
that Aegis has will simply do nothing.</p>

<p>Every router should add some default annoatations and metadata automatically for you. Whether your
trace strategy handles that data is another story. So if you are using X-Ray, you don&rsquo;t need to add
the API Gateway request path or HTTP method. If you run Aegis with all the defaults, you&rsquo;re just going
to get traced API requests with meaningful annotations.</p>

<h2 id="segments">Segments</h2>

<p><code>BeginSegment()</code> and <code>BeginSubsegment()</code> are somewhat universal concepts. AWS X-Ray has the concept
of segments and subsegments, but other tracing services may only deal with segments. Those segments
may even be implicit so you may find yourself not needing to implement these functions in a custom
strategy depending on the service you&rsquo;re using.</p>

<p>Regardless, all they do is help organize and segment your traces. In the case of X-Ray, Aegis will
automatically create an &ldquo;Aegis&rdquo; segment for you when running Aegis from the CLI or local web server.
When running in AWS Lambda, a segment is created automatically by Lambda for you.</p>

<p>This may not be the case if using a custom trace strategy. You may also want to create subsegments
to trace within your handlers. These are the functions to help you out.</p>

<p><code>CloseSegment()</code> and <code>CloseSubsegment()</code> then help you define the end of those segments. In the
case of the default <code>XRayTraceStrategy</code>, closing a subsegment also sends data off to X-Ray. These
functions just call X-Ray&rsquo;s <code>Close()</code> and <code>CloseAndStream()</code>. They&rsquo;re aliases more or less.</p>

<h2 id="recording-data">Recording Data</h2>

<p>Regardless of the tracing service you ultimately use, the concept of <code>Record()</code> is pretty universal.
The idea is that you want to record certain bits of data with your tracing. AWS X-Ray calls these
&ldquo;metadata,&rdquo; &ldquo;annotations,&rdquo; &ldquo;namespaced annotations,&rdquo; and a single &ldquo;error&rdquo; that can be sent along with
each trace.</p>

<p>The <code>XRayTraceStrategy</code> implementation of <code>Record()</code> will simply set some struct fields with the data
and nothing will actually be &ldquo;sent&rdquo; to AWS X-Ray until <code>Capture()</code> or <code>CaptureAsync()</code> is called.</p>

<p>The reason for this is because we aren&rsquo;t &ldquo;streaming&rdquo; a bunch of data to AWS X-Ray. We&rsquo;re &ldquo;reporting&rdquo;
on segments of our application. Your trace strategy may differ and there&rsquo;s no reason <code>Record()</code> couldn&rsquo;t
send &ldquo;real-time&rdquo; data along. It&rsquo;s just not how X-Ray works.</p>

<p>Another important thing to note here is that <code>Record()</code> can be called at any time without context.
In the case of Aegis, it&rsquo;s called before (and outside of) whatever <code>Capture()</code> is wrapping. So there
is no context. If we needed the context, we&rsquo;d call <code>Record()</code> inside of <code>Capture()</code> which has context.
Or, the specific context we care about.</p>

<p>By the time <code>Tracer</code> is given to your handler, you do have the relevant context. So you could leverage
it to pull out whatever data you need.</p>

<p>The idea is that <code>Record()</code> shouldn&rsquo;t <em>require</em> a context argument. While AWS X-Ray&rsquo;s internal methods
for recording annotations and metadata do take a context (for the segment), we don&rsquo;t know if other trace
services are going to use the context or not. So removing this requirement from the process keeps
<code>TraceStrategy</code> a lot more flexible as an interface.</p>

<h2 id="tracing-functions">Tracing Functions</h2>

<p><code>Capture()</code> and <code>CaptureAsync()</code> (for goroutinues) are &ldquo;wrappers.&rdquo; They wrap the functions you wish to trace.
In the case of AWS X-Ray, this captures things like execution time and more. Perhaps most important of all here
is that they can capture errors.</p>

<p>What exactly will be traced is going to vary by the trace service (or your own code if you roll your own).
In the case of AWS X-Ray, a lot is actually traced for you. How long HTTP connections took, how long it
took to marshal things, and more.</p>

<p>One of the biggest things you&rsquo;re going to see in X-Ray is how long your handlers took to execute and how long
your Lambda took to execute. This really starts to give you a good idea about performance and where your
bottlenecks are.</p>

<p><img src="/aegis/img/xray-example-trace.jpg" alt="X-Ray trace example" title="X-Ray example trace" /></p>

<p>An important thing to note about Lambda here is that X-Ray is also going to illustrate for you the difference
between a &ldquo;cold&rdquo; and &ldquo;warm&rdquo; start in Lambda. You&rsquo;ll notice in the screenshot above here that the Lambda took
over 800ms to run. Not terrible for API Gateway and all the OAuth work that was going on, but also not stellar.
Subsequent invocations were faster because the Lambda container was &ldquo;warm&rdquo; and some data retrieved from the IDP
service (such as the <code>DescribeUserPool</code> and <code>DescribeUserPoolClient</code> calls) were already cached. Things like the
well known ket set and so on.</p>

<p>As you learn to leverage caching methods and tune your service configurations, you&rsquo;ll be able to visually see
the performance change over time with X-Ray. It&rsquo;s an incredibly useful service.</p>

    
        

<h1 id="custom">Custom</h1>

<p>You can inject your own handler dependencies under the <code>Custom</code> field. This is great for 3rd party dependencies you
wish to use as well as anything you want to make available to each handler.</p>

<p>These dependencies contain no &ldquo;configuration&rdquo; closure (unlike Services) and if your function is simple enough, you
may not even need to pass them through <code>Custom</code>. Keep in mind the scoping in Go. If you&rsquo;ve defined something in
your package (&ldquo;main&rdquo; perhaps), it&rsquo;s available to all of the functions within that package&hellip;This often will include
your handlers.</p>

<p>So before you reach to shove everything through to your handlers, think about it a bit. Lambda functions should
be easy to follow and your code should read clean. Remember that <code>Custom</code> here is a <span class="nowrap"><code>map[string]interface{}</code></span>
so you will likely encounter the need to check for nil and use type assertions.</p>

<p>Aegis isn&rsquo;t trying to limit you and sometimes you may have no other option, but no one says you have to pass
everything through to each handler in this way.</p>

    
        

<h1 id="services">Services</h1>

<blockquote>
<p>From the Cognito example Aegis app</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">AegisApp</span><span class="p">.</span><span class="nx">ConfigureService</span><span class="p">(</span><span class="s">&#34;cognito&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">evt</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="c1">// Automatically get host. You don&#39;t need to do this - you typically would have a known domain name to use.
</span><span class="c1"></span>    <span class="nx">host</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
    <span class="nx">stage</span> <span class="o">:=</span> <span class="s">&#34;prod&#34;</span>
    <span class="k">if</span> <span class="nx">headers</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">evt</span><span class="p">[</span><span class="s">&#34;headers&#34;</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">headersMap</span> <span class="o">:=</span> <span class="nx">headers</span><span class="p">.(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
        <span class="k">if</span> <span class="nx">hostValue</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">headersMap</span><span class="p">[</span><span class="s">&#34;Host&#34;</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">host</span> <span class="p">=</span> <span class="nx">hostValue</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// Automatically get API stage
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">requestContext</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">evt</span><span class="p">[</span><span class="s">&#34;requestContext&#34;</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="nx">requestContextMap</span> <span class="o">:=</span> <span class="nx">requestContext</span><span class="p">.(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
        <span class="k">if</span> <span class="nx">stageValue</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">requestContextMap</span><span class="p">[</span><span class="s">&#34;stage&#34;</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">stage</span> <span class="p">=</span> <span class="nx">stageValue</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">CognitoAppClientConfig</span><span class="p">{</span>
        <span class="c1">// The following three you&#39;ll need to fill in or use secrets.
</span><span class="c1"></span>        <span class="c1">// See README for more info, but set secrets using aegis CLI and update aegis.yaml as needed.
</span><span class="c1"></span>        <span class="nx">Region</span><span class="p">:</span>   <span class="s">&#34;us-east-1&#34;</span><span class="p">,</span>
        <span class="nx">PoolID</span><span class="p">:</span>   <span class="nx">AegisApp</span><span class="p">.</span><span class="nx">GetVariable</span><span class="p">(</span><span class="s">&#34;PoolID&#34;</span><span class="p">),</span>
        <span class="nx">ClientID</span><span class="p">:</span> <span class="nx">AegisApp</span><span class="p">.</span><span class="nx">GetVariable</span><span class="p">(</span><span class="s">&#34;ClientID&#34;</span><span class="p">),</span>
        <span class="c1">// This is just automatic for the example, you would likely replace this too
</span><span class="c1"></span>        <span class="nx">RedirectURI</span><span class="p">:</span>       <span class="s">&#34;https://&#34;</span> <span class="o">+</span> <span class="nx">host</span> <span class="o">+</span> <span class="s">&#34;/&#34;</span> <span class="o">+</span> <span class="nx">stage</span> <span class="o">+</span> <span class="s">&#34;/callback&#34;</span><span class="p">,</span>
        <span class="nx">LogoutRedirectURI</span><span class="p">:</span> <span class="s">&#34;https://&#34;</span> <span class="o">+</span> <span class="nx">host</span> <span class="o">+</span> <span class="s">&#34;/&#34;</span> <span class="o">+</span> <span class="nx">stage</span> <span class="o">+</span> <span class="s">&#34;/&#34;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">})</span></code></pre></div>
<p>Handler dependencies contain <code>Services</code> too. These are primarily AWS services like AWS Cognito for example.
They are a bit different than a simple field on the <code>Aegis</code> interface because they are &ldquo;services&rdquo; that can
carry configurations which often need to be dynamic.</p>

<p>However, services are really just dependencies as well. Your normal dependencies, set on the <code>Aegis</code>
interface can not be configured dynamically. You set the dependency on the interface and that&rsquo;s it.</p>

<p>Using <code>ConfigureService()</code> is the important function here. The first argument for this function is the name
of the service you wish to configure. The second argument is a function. That function is given the context
and the event from Lambda. However, this configuration is applied before your event handler is called.</p>

<aside class="not-warning">
Take care when configuring services since you have access to the Lambda event. You could accidentally
alter the event in a way your handler is not expecting.
</aside>

<h2 id="filters">Filters</h2>

<p>There are hooks or &ldquo;filters&rdquo; available to use here for the handler as well. The Aegis interface has
a field called <code>Filters</code> for various filters, the ones most helpful to services is likely the
<span class="nowrap"><code>Filters.Handler.BeforeServices</code></span> filter.</p>

<h2 id="custom-services">Custom Services</h2>

<p>3rd party services can also be added and configured. They are available under the <code>Custom</code> field.</p>

<p>TBD - not fully implemented</p>

    

        </div>
        <div class="dark-box">
            
        </div>
    </div>
    
</body>
</html>
