<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DocuAPI Example Site</title>
    <link>https://tmaiaroto.github.io/aegis/</link>
    <description>Recent content on DocuAPI Example Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://tmaiaroto.github.io/aegis/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/cli/1_init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/cli/1_init/</guid>
      <description>Init The first CLI command you may use, especially when getting started, is aegis init. This will create a main.go and aegis.yaml file in the current directory.
Note that if you already have either of these files present, the command will not replace or touch your existing files.
The contents of main.go include a short boilerplate example Aegis application with API Gateway event handling via the Router.
The aegis.yaml then includes configuration for creating an API Gateway upon deploy.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/cli/2_deploy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/cli/2_deploy/</guid>
      <description>Deploy The aegis deploy command will likely be the next command you&amp;rsquo;re after. Running it anywhere there is buildable Go code as well as an aegis.yaml will result in a deployment to AWS.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/handler-dependencies/1_dependencies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/handler-dependencies/1_dependencies/</guid>
      <description>Handler Dependencies Handlers need a variety of services and dependencies in order to make life easier. It&amp;rsquo;s a very big part of why one reaches for a framework. The idea of &amp;ldquo;dependency injection&amp;rdquo; is the foundation of many frameworks and Aegis isn&amp;rsquo;t much different.
Really, routing events to handlers is the foundation of Aegis, but you can&amp;rsquo;t abstract that away without being able to pass along functionality required by each handler.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/handler-dependencies/2_log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/handler-dependencies/2_log/</guid>
      <description>Log logger := logrus.New() // Various configuration options for logrus...  AegisApp = aegis.New(handlers) // Set your configured logger on Log AegisApp.Log = logger AegisApp.Start() Aegis&amp;rsquo; Log dependency provides an adaptable way to log using the popular Go package logrus. You&amp;rsquo;re certainly welcome to use the standard library log package as well. AWS Lambda will send all of that stdout to CloudWatch for you automatically.
However, there may be other logging services you wish to use.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/handler-dependencies/3_tracer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/handler-dependencies/3_tracer/</guid>
      <description>Tracer  How to use a different TraceStrategy
 AegisApp = aegis.New(handlers) // For example, disabling tracing AegisApp.Tracer = &amp;amp;aegis.NoTraceStrategy{} AegisApp.Start()  How Aegis Router traces internally
 // Records data in the tracing strategy. In this case, and by default, X-Ray annotations. r.Tracer.Record(&amp;#34;annotation&amp;#34;, map[string]interface{}{ &amp;#34;RequestPath&amp;#34;: req.Path, &amp;#34;Method&amp;#34;: req.HTTPMethod, }, ) err = r.Tracer.Capture(ctx, &amp;#34;RouteHandler&amp;#34;, func(ctx1 context.Context) error { // Makes the Tracer available inside your handler.  // Capture() also applies the annotations from above in the case of XRayTraceStrategy  d.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/handler-dependencies/4_custom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/handler-dependencies/4_custom/</guid>
      <description>Custom You can inject your own handler dependencies under the Custom field. This is great for 3rd party dependencies you wish to use as well as anything you want to make available to each handler.
These dependencies contain no &amp;ldquo;configuration&amp;rdquo; closure (unlike Services) and if your function is simple enough, you may not even need to pass them through Custom. Keep in mind the scoping in Go. If you&amp;rsquo;ve defined something in your package (&amp;ldquo;main&amp;rdquo; perhaps), it&amp;rsquo;s available to all of the functions within that package&amp;hellip;This often will include your handlers.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/handler-dependencies/5_services/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/handler-dependencies/5_services/</guid>
      <description>Services  From the Cognito example Aegis app
 AegisApp.ConfigureService(&amp;#34;cognito&amp;#34;, func(ctx context.Context, evt map[string]interface{}) interface{} { // Automatically get host. You don&amp;#39;t need to do this - you typically would have a known domain name to use.  host := &amp;#34;&amp;#34; stage := &amp;#34;prod&amp;#34; if headers, ok := evt[&amp;#34;headers&amp;#34;]; ok { headersMap := headers.(map[string]interface{}) if hostValue, ok := headersMap[&amp;#34;Host&amp;#34;]; ok { host = hostValue.(string) } } // Automatically get API stage  if requestContext, ok := evt[&amp;#34;requestContext&amp;#34;]; ok { requestContextMap := requestContext.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/helpers/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/helpers/http/</guid>
      <description>API Gateway Proxy (HTTP) There are quite a few helpers for working with API Gateway Proxy responses and requests. You can read about all of them through Go documentation.
 APIGatewayProxyResponse APIGatewayProxyRequest  Though let&amp;rsquo;s take a look at some of the more common ones here.
APIGatewayProxyRequest API Gateway requests are not HTTP requests. They come into Lambda as JSON messages. The AWS Lambda Go package, and therefore Aegis, marshals these messages to structs.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/1_routers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/1_routers/</guid>
      <description>Routers First things first. The AWS Lambda Go package is used by Aegis. In fact, it&amp;rsquo;s basically required for native Go support in Lambda. I don&amp;rsquo;t think anyone wants to write a competing package (that&amp;rsquo;d be silly). However, that package is designed to be lightweight. It does not include a bunch of creature comforts. That&amp;rsquo;s where Aegis routers come in handy.
Above all else, there is a default handler that can be used for any incoming Lambda event.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/2_api_gateway/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/2_api_gateway/</guid>
      <description>API Gateway Router  This should look familiar if you&amp;rsquo;ve built an HTTP RESTful API in Go before
 package main import aegis &amp;#34;github.com/tmaiaroto/aegis/framework&amp;#34; func main() { // Handle an APIGatewayProxyRequest event with a URL request path Router  router := aegis.NewRouter(fallThrough) router.Handle(&amp;#34;GET&amp;#34;, &amp;#34;/&amp;#34;, handleRoot) // Register the handler  app := aegis.New(aegis.Handlers{ Router: router, }) // A blocking call that listens for events  app.Start() } // fallThrough handles any path that couldn&amp;#39;t be matched to another handler func fallThrough(ctx context.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/3_tasker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/3_tasker/</guid>
      <description>Tasker The Tasker is an interface to route scheduled jobs or &amp;ldquo;tasks&amp;rdquo; that your Lambda may perform. This works in conjunction with CloudWatch Rules. So you&amp;rsquo;ll need to have events setn to your Lambda from CloudWatch.
{ &amp;#34;schedule&amp;#34;: &amp;#34;rate(1 minute)&amp;#34;, &amp;#34;disabled&amp;#34;: true, &amp;#34;input&amp;#34;: { &amp;#34;_taskName&amp;#34;: &amp;#34;test&amp;#34;, &amp;#34;foo&amp;#34;: &amp;#34;bar&amp;#34; } } Aegis makes this easy to do through a conventional approach. You need not configure CloudWatch events manually (though you can of course).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/4_rpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/4_rpc/</guid>
      <description>RPC Router  Route and handle by name
 func main() { rpcRouter := aegis.NewRPCRouter() rpcRouter.Handle(&amp;#34;lookup&amp;#34;, handleLookup) app := aegis.New(aegis.Handlers{ // Again, your one function can handle different event types  // Router: router,  RPCRouter: rpcRouter, }) app.Start() } func handleLookup(ctx context.Context, d *aegis.HandlerDependencies, evt map[string]interface{}) (map[string]interface{}, error) { // Some GeoIP look would happen here and some data would be returned  return map[string]string{&amp;#34;city&amp;#34;: &amp;#34;Somewhereville&amp;#34;}, nil }  Example GeoIP lookup from another Lambda</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/5_s3object/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/5_s3object/</guid>
      <description>S3 Object Router func main() { s3Router := aegis.NewS3ObjectRouterForBucket(&amp;#34;aegis-incoming&amp;#34;) // s3Router.Handle(&amp;#34;s3:ObjectCreated:Put&amp;#34;, &amp;#34;*.png&amp;#34;, handleS3Upload)  // Put() is a shortcut for the above  s3Router.Put(&amp;#34;*.png&amp;#34;, handleS3Upload) handlers := aegis.Handlers{ S3ObjectRouter: s3Router, } } func handleS3Upload(ctx context.Context, d *aegis.HandlerDependencies, evt *aegis.S3Event) error { // evt will contain bucket name, path, etc.  return nil } Now here we have an interesting Router. Like the API Gateway Proxy, we have a few things to match on.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/6_ses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/6_ses/</guid>
      <description>SES Router func main() { sesReceiver := aegis.NewSESRouter() sesReceiver.Handle(&amp;#34;*@ses.serifandsemaphore.io&amp;#34;, handleEmail) handlers := aegis.Handlers{ SESRouter: sesReceiver, } AegisApp = aegis.New(handlers) AegisApp.Start() } func handleEmail(ctx context.Context, d *aegis.HandlerDependencies, evt *aegis.SimpleEmailEvent) error { log.Println(evt) return nil } The AWS SES (Simple E-mail Service) router, SESRouter, and the ability for a Lambda to receive e-mail is perhaps one of the coolest things ever. Yes, there is such a thing as serverless e-mail.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/7_cognito/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/7_cognito/</guid>
      <description>Cognito Router There are some AWS Cognito specific events that can be routed as well.</description>
    </item>
    
  </channel>
</rss>