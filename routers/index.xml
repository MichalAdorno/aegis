<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Routers on DocuAPI Example Site</title>
    <link>https://tmaiaroto.github.io/aegis/routers/</link>
    <description>Recent content in Routers on DocuAPI Example Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://tmaiaroto.github.io/aegis/routers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/1_routers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/1_routers/</guid>
      <description>Routers First things first. The AWS Lambda Go package is used by Aegis. In fact, it&amp;rsquo;s basically required for native Go support in Lambda. I don&amp;rsquo;t think anyone wants to write a competing package (that&amp;rsquo;d be silly). However, that package is designed to be lightweight. It does not include a bunch of creature comforts. That&amp;rsquo;s where Aegis routers come in handy.
Above all else, there is a default handler that can be used for any incoming Lambda event.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/2_api_gateway/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/2_api_gateway/</guid>
      <description>API Gateway Router  This should look familiar if you&amp;rsquo;ve built an HTTP RESTful API in Go before
 package main import aegis &amp;#34;github.com/tmaiaroto/aegis/framework&amp;#34; func main() { // Handle an APIGatewayProxyRequest event with a URL request path Router  router := aegis.NewRouter(fallThrough) router.Handle(&amp;#34;GET&amp;#34;, &amp;#34;/&amp;#34;, handleRoot) // Register the handler  app := aegis.New(aegis.Handlers{ Router: router, }) // A blocking call that listens for events  app.Start() } // fallThrough handles any path that couldn&amp;#39;t be matched to another handler func fallThrough(ctx context.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/3_tasker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/3_tasker/</guid>
      <description>Tasker The Tasker is an interface to route scheduled jobs or &amp;ldquo;tasks&amp;rdquo; that your Lambda may perform. This works in conjunction with CloudWatch Rules. So you&amp;rsquo;ll need to have events setn to your Lambda from CloudWatch.
{ &amp;#34;schedule&amp;#34;: &amp;#34;rate(1 minute)&amp;#34;, &amp;#34;disabled&amp;#34;: true, &amp;#34;input&amp;#34;: { &amp;#34;_taskName&amp;#34;: &amp;#34;test&amp;#34;, &amp;#34;foo&amp;#34;: &amp;#34;bar&amp;#34; } } Aegis makes this easy to do through a conventional approach. You need not configure CloudWatch events manually (though you can of course).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/4_rpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/4_rpc/</guid>
      <description>RPC Router  Route and handle by name
 func main() { rpcRouter := aegis.NewRPCRouter() rpcRouter.Handle(&amp;#34;lookup&amp;#34;, handleLookup) app := aegis.New(aegis.Handlers{ // Again, your one function can handle different event types  // Router: router,  RPCRouter: rpcRouter, }) app.Start() } func handleLookup(ctx context.Context, d *aegis.HandlerDependencies, evt map[string]interface{}) (map[string]interface{}, error) { // Some GeoIP look would happen here and some data would be returned  return map[string]string{&amp;#34;city&amp;#34;: &amp;#34;Somewhereville&amp;#34;}, nil }  Example GeoIP lookup from another Lambda</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/5_s3object/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/5_s3object/</guid>
      <description>S3 Object Router func main() { s3Router := aegis.NewS3ObjectRouterForBucket(&amp;#34;aegis-incoming&amp;#34;) // s3Router.Handle(&amp;#34;s3:ObjectCreated:Put&amp;#34;, &amp;#34;*.png&amp;#34;, handleS3Upload)  // Put() is a shortcut for the above  s3Router.Put(&amp;#34;*.png&amp;#34;, handleS3Upload) handlers := aegis.Handlers{ S3ObjectRouter: s3Router, } } func handleS3Upload(ctx context.Context, d *aegis.HandlerDependencies, evt *aegis.S3Event) error { // evt will contain bucket name, path, etc.  return nil } Now here we have an interesting Router. Like the API Gateway Proxy, we have a few things to match on.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/6_ses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/6_ses/</guid>
      <description>SES Router func main() { sesReceiver := aegis.NewSESRouter() sesReceiver.Handle(&amp;#34;*@ses.serifandsemaphore.io&amp;#34;, handleEmail) handlers := aegis.Handlers{ SESRouter: sesReceiver, } AegisApp = aegis.New(handlers) AegisApp.Start() } func handleEmail(ctx context.Context, d *aegis.HandlerDependencies, evt *aegis.SimpleEmailEvent) error { log.Println(evt) return nil } The AWS SES (Simple E-mail Service) router, SESRouter, and the ability for a Lambda to receive e-mail is perhaps one of the coolest things ever. Yes, there is such a thing as serverless e-mail.
You can route based on any address match, or address matches within a specific domain, using NewSESRouter() and NewSESRouterForDomain() respectively.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/7_sqs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/7_sqs/</guid>
      <description>SQS Router func main() { sqsRouter := aegis.NewSQSRouterForBucket(&amp;#34;aegis-queue&amp;#34;) sqsRouter.Handle(&amp;#34;attr&amp;#34;, &amp;#34;value&amp;#34;, handleSQSMessage) handlers := aegis.Handlers{ SQSRouter: sqsRouter, } } func handleSQSMessage(ctx context.Context, d *aegis.HandlerDependencies, evt *aegis.SQSEvent) error { // evt will contain the message body, attributes, etc.  return nil } Each SQS queue allows one Lambda to be invoked when new messages enter the queue. However, multiple queues may go to trigger the same Lambda function. This router plays an important role here.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tmaiaroto.github.io/aegis/routers/8_cognito/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tmaiaroto.github.io/aegis/routers/8_cognito/</guid>
      <description>Cognito Router There are some AWS Cognito specific events that can be routed as well. These events are for User Pool workflows. You can find more information about the Cognito triggers here.
The Cognito router is matching on the triggerSource value here. You also can have separate handlers for different User Pools. You&amp;rsquo;ll just need to set a PoolID on the router or use NewCognitoRouterForPool() instead of NewCognitoRouter().
Perhaps the most interesting or useful thing about this router is the ability to have your Lambda easily add functionality to AWS Cognito.</description>
    </item>
    
  </channel>
</rss>