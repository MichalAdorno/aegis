<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Routers</title>
    <link href='/aegis/slate/stylesheets/monokai.css' rel="stylesheet" media="screen" />
<link href='/aegis/slate/stylesheets/screen.css' rel="stylesheet" media="screen" />
<link href='/aegis/slate/stylesheets/print.css' rel="stylesheet" media="print" />

    <link href='/aegis/css/styles.css' rel="stylesheet"/>
    <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.0.13/css/solid.css" integrity="sha384-drdlAcijFWubhOfj9OS/gy2Gs34hVhVT90FgJLzrldrLI+7E7lwBxmanEEhKTRTS" crossorigin="anonymous">
<link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.0.13/css/fontawesome.css" integrity="sha384-LDuQaX4rOgqi4rbWCyWj3XVBlgDzuxGy/E6vWN6U7c25/eSJIwyKhy9WgZCHQWXz" crossorigin="anonymous">
    
<script src='/aegis/slate/javascripts/all.js'></script>

    
</head>
<body class="index" data-languages="">
    <div class="main-nav-wrapper">
        <ul class="main-menu">
            <li class="">
    <a href="/aegis/">Getting Started</a>
</li>


    
    <li class="active">
        <a href="/aegis/routers/" title="Aegis Routers">Routers</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/handler-dependencies/" title="Aegis Dependencies">Dependencies</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/helpers/" title="Aegis Helpers">Helpers</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/cli/" title="Aegis Command Line Interface">CLI</a>
    </li>
    

        </ul>
    </div>
    <a href="#" id="nav-button">
        <span>
        NAV
        <img src='/aegis/slate/images/navbar.png'/>
      </span>
    </a>
    <div class="tocify-wrapper">
        
         
 <div id="logo-type">
    <h1 class="toc-ignore">Aegis</h1>
    <h2 class="toc-ignore">An AWS Serverless Framework for Go</h2>
</div>
         
        <aside class="main-menu-sidebar-wrapper">
    <ul class="main-menu-sidebar">
        <li class="">
    <a href="/aegis/">Getting Started</a>
</li>


    
    <li class="active">
        <a href="/aegis/routers/" title="Aegis Routers">Routers</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/handler-dependencies/" title="Aegis Dependencies">Dependencies</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/helpers/" title="Aegis Helpers">Helpers</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/cli/" title="Aegis Command Line Interface">CLI</a>
    </li>
    

    </ul>
</aside>
        
        <div class="search">
            <input type="text" class="search" id="input-search" placeholder='Search This Section'>
        </div>
        <ul class="search-results"></ul>
        
        <div id="toc">
        </div>
         
        
        <ul class="toc-footer">
            
            <li>Hugo Theme by <a href="https://github.com/bep" target="_blank">bep</a></li>
            
        </ul>
        
        
    </div>
    <div class="page-wrapper">
        <div class="dark-box"></div>
        <div class="content">
            
    
        <h1 class="toc-ignore">Routers</h1>

<p>First things first. The <a href="https://github.com/aws/aws-lambda-go" target="_blank">AWS Lambda Go package</a>
is used by Aegis. In fact, it&rsquo;s basically required for native Go support in Lambda. I don&rsquo;t think anyone wants
to write a competing package (why??). However, that package is designed to be lightweight. It does not include
a bunch of creature comforts. That&rsquo;s where Aegis routers come in handy.</p>

<p>Above all else, there is a default handler that can be used for any incoming Lambda event. This is called
the <code>DefaultHandler</code>. Aegis routers aim to make life easier without hiding all of the unknowns in life. You
can always handle incoming JSON event messages as maps.</p>

<p>However, there&rsquo;s some very helpful routers to help direct events to your handlers. You&rsquo;re probably looking
to use a framework because you don&rsquo;t want to write all that logic yourself, right?</p>

<p>One last quick note: All of the routers you see below can be used on the same Lambda function. Aegis does not
restrict your Lambda to handling just one type of event. The design of your functions is entirely up to you.</p>

    
        

<h1 id="api-gateway-router">API Gateway Router</h1>

<blockquote>
<p>This should look familiar if you&rsquo;ve built an HTTP RESTful API in Go before</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="nx">aegis</span> <span class="s">&#34;github.com/tmaiaroto/aegis/framework&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Handle an APIGatewayProxyRequest event with a URL request path Router
</span><span class="c1"></span>    <span class="nx">router</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">NewRouter</span><span class="p">(</span><span class="nx">fallThrough</span><span class="p">)</span>
    <span class="nx">router</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">handleRoot</span><span class="p">)</span>

    <span class="c1">// Register the handler
</span><span class="c1"></span>    <span class="nx">app</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">Handlers</span><span class="p">{</span>
        <span class="nx">Router</span><span class="p">:</span> <span class="nx">router</span><span class="p">,</span>
    <span class="p">})</span>
    <span class="c1">// A blocking call that listens for events
</span><span class="c1"></span>    <span class="nx">app</span><span class="p">.</span><span class="nx">Start</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// fallThrough handles any path that couldn&#39;t be matched to another handler
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">fallThrough</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">HandlerDependencies</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">APIGatewayProxyRequest</span><span class="p">,</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">APIGatewayProxyResponse</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="p">=</span> <span class="mi">404</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// handleRoot is handling GET &#34;/&#34; in this case
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">handleRoot</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">HandlerDependencies</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">APIGatewayProxyRequest</span><span class="p">,</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">APIGatewayProxyResponse</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span><span class="s">&#34;event&#34;</span><span class="p">:</span> <span class="nx">req</span><span class="p">})</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span></code></pre></div>
<p>Perhaps the most common event handler is for API Gateway requests. When you think about a router for a web
application, typically handling HTTP requests comes to mind. So the Aegis&rsquo; router for this is simply <code>Router</code>.</p>

<p>While the concept of serverless applications and &ldquo;event handling&rdquo; brings about far more opportunties to &ldquo;route&rdquo;
events, this interface takes the less the descriptive name purely due to familiarity.</p>

<p>The <code>Router</code> works with an <code>ANY</code> method on a wildcard path in API Gateway. Instead of defining paths and methods
to associate with different Lambda functions, Aegis prefers a simpler approach. Though you aren&rsquo;t bound to this,
it certainly makes things a lot easier. However, keep in mind that your Lambda function will be triggered by
API Gateway on literally any request.</p>

<p>Amazon&rsquo;s official <a href="https://github.com/aws/aws-lambda-go" target="_blank">AWS Lambda Go</a> package will
marshal the incoming JSON event message to an API Gateway Proxy Request struct of some sort. Aegis does exactly
the same thing, in fact, it aliases Amazon&rsquo;s struct. The AWS Lambda Go package handles quite a number of different
type of events by converting them into native Go structs. However, you can always handle a plain old map too.</p>

<p>Aegis adds helper functions on to several AWS Lambda Go structs. The goal is to make it feel more familiar for anyone
who has ever written an API in Go before. Also take a look at the <code>res</code> variable in the example code. See how you
can easily set <code>res.StatusCode</code> and return data with the <code>res.JSON()</code> helper function?</p>

<p>Note that every single handled event in Aegis has a return value, which is an <code>error</code>. You&rsquo;ll most often simply
return <code>nil</code>, but if you do return an actual error, it will be returned in the response in this case. Other routers
may have no where to return the error of course, but a <a href="/handler-dependencies/#tracer">tracer</a> might handle it
(for example, AWS X-Ray will handle it).</p>

<p>You could also return your own error with appropriate status code with body content. For example, you could return
a JSON body response that contains the error with a status code of 500. There&rsquo;s even a helper function for this as
well: <code>res.JSONError(500, e)</code> That will return the text of the error in a JSON message.</p>

<h2 id="apigatewayproxyrequest">APIGatewayProxyRequest</h2>

<p>This struct will contain a good bit of information from API Gateway. Most important of all, it will include HTTP
request headers, body, and querystring parameters.</p>

<p>There are a bunch of helpers that you can read about in the <a href="/helpers/#http-proxy-helpers">HTTP (Proxy) Helpers section</a>.
Examples include; <code>IP()</code> which returns the IP address of the client. <code>GetForm</code> which returns form-data from the request.
<code>Cookies()</code> which returns the cookies from the request. These are convenient functions that AWS&rsquo; core Go Lambda package
does not provide, but Aegis&rsquo; aliased version does.</p>

<h2 id="apigatewayproxyresponse">APIGatewayProxyResponse</h2>

<p>This struct is responsible for the response from handled HTTP requests. Ultimately everything in AWS Lambda comes
in as JSON and goes out as JSON. API Gateway will transform the response as needed, but Lambda deals with JSON for
its messaging format.</p>

<p>Therefore, <code>APIGatewayProxyResponse</code> is unmarshaled by the AWS Lambda Go package but, you get to work with a nice
struct that can have functions composed on to it. Again, helpers for this response include things like setting status
codes, body content, headers, and more.</p>

<p>Like <code>APIGatewayProxyRequest</code>, the response struct is also an alias of the AWS Lambda Go package.</p>

<h2 id="fall-through-handler">Fall Through Handler</h2>

<p>When creating a new <code>Router</code> you can define a &ldquo;fall through&rdquo; or &ldquo;catch all&rdquo; handler as seen in the example code snippet.
This will handle any request not matched by your router. A common handler in this case is simple one that does nothing,
but sets a <code>StatusCode</code> of 404.</p>

<aside class="note-info">
<i class="fas fa-info-circle"></i> Some routers in Aegis have optional fall through handlers. The API Gateway Router's fall through is not optional.
</aside>

<h2 id="middleware">Middleware</h2>

<p>Aegis&rsquo; router also supports middleware. Standard Go http library middleware at that.</p>

    
        

<h1 id="tasker">Tasker</h1>

<p>The <code>Tasker</code> is an interface to route scheduled jobs or &ldquo;tasks&rdquo; that your Lambda may perform. This works
in conjunction with CloudWatch Rules. So you&rsquo;ll need to have events setn to your Lambda from CloudWatch.</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;schedule&#34;</span><span class="p">:</span> <span class="s2">&#34;rate(1 minute)&#34;</span><span class="p">,</span>
    <span class="nt">&#34;disabled&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nt">&#34;input&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;_taskName&#34;</span><span class="p">:</span> <span class="s2">&#34;test&#34;</span><span class="p">,</span>
        <span class="nt">&#34;foo&#34;</span><span class="p">:</span> <span class="s2">&#34;bar&#34;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>Aegis makes this easy to do through a conventional approach. You need not configure CloudWatch events
manually (though you can of course). You also don&rsquo;t add them to your <code>aegis.yaml</code> or anything like that.
It&rsquo;s much easier; you&rsquo;ll just add a <code>tasks</code> directory at the root of your source code where you run
<code>aegis deploy</code>. Within this directory, you can include JSON files for each scheduled task you&rsquo;d like
to set up.</p>

<h3 id="task-json-definition-format">Task JSON Definition Format</h3>

<p>The first key being <code>schedule</code> which takes a CloudWatch Event Rule expression (ie. &ldquo;rate&rdquo; or crontab format).
The optional <code>disabled</code> key in your JSON task definition can disable your CloudWatch rule so you don&rsquo;t
need to delete it just to turn it off for a while.</p>

<p>Then you have the <code>input</code> key which contains an object that has your event message. This can be anything
you want. It comes in to your handler as a <code>map[string]interface{}</code> and is &ldquo;static JSON&rdquo; in terms of
the CloudWatch Rule configuration.</p>

<p>There is a conventional <code>_taskName</code> key in your payload that you need to be aware of. This is what gets
matched by the <code>Tasker</code> in order to delegate to your handlers.</p>

<aside class="note-info">
<i class="fas fa-info-circle"></i> Note that tasks are routed by exact match.
</aside>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tasker</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">NewTasker</span><span class="p">(</span><span class="nx">taskerFallThrough</span><span class="p">)</span>
<span class="nx">tasker</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="nx">handleTestTask</span><span class="p">)</span></code></pre></div>
<blockquote>
<p>The handler should look familiar, excpet that the event is simply a map</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Example task handler
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">handleTestTask</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">HandlerDependencies</span><span class="p">,</span> <span class="nx">evt</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Handling task!&#34;</span><span class="p">,</span> <span class="nx">evt</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span></code></pre></div>
<h3 id="handling-tasks">Handling Tasks</h3>

<p>Like the API Gateway Proxy Request <code>Router</code>, <code>Tasker</code> has a &ldquo;fall through&rdquo; or &ldquo;catch all&rdquo; as well.
It&rsquo;s function signature is no different than any other task handler. This fall through handler is also
optional. You can call <code>aegis.NewTasker()</code> to use just as well. In that case, if your configured <code>Tasker</code>
does not match any task names, it will not route those events and they won&rsquo;t be handled.</p>

<p>Obviously, there is no one to return a response message to in the case of a scheduled job. An <code>error</code>, or <code>nil</code>,
must still be returned. Though the error would only be for the benefit of your tracing tool (ie. X-Ray will see it).</p>

<p>The event in this case will be whatever you defined in the definition JSON. Often times you may find that the
most important thing is the specific handler function itself is called and not so much this static JSON payload.</p>

    
        

<h1 id="rpc-router">RPC Router</h1>

<blockquote>
<p>Route and handle by name</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">rpcRouter</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">NewRPCRouter</span><span class="p">()</span>
    <span class="nx">rpcRouter</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&#34;lookup&#34;</span><span class="p">,</span> <span class="nx">handleLookup</span><span class="p">)</span>

    <span class="nx">app</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">Handlers</span><span class="p">{</span>
        <span class="c1">// Again, your one function can handle different event types
</span><span class="c1"></span>        <span class="c1">// Router: router,
</span><span class="c1"></span>        <span class="nx">RPCRouter</span><span class="p">:</span> <span class="nx">rpcRouter</span><span class="p">,</span>
    <span class="p">})</span>
    <span class="nx">app</span><span class="p">.</span><span class="nx">Start</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleLookup</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">HandlerDependencies</span><span class="p">,</span> <span class="nx">evt</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Some GeoIP look would happen here and some data would be returned
</span><span class="c1"></span>    <span class="k">return</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;city&#34;</span><span class="p">:</span> <span class="s">&#34;Somewhereville&#34;</span><span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span></code></pre></div>
<blockquote>
<p>Example GeoIP lookup from another Lambda</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">rpcPayload</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
    <span class="s">&#34;_rpcName&#34;</span><span class="p">:</span>  <span class="s">&#34;lookup&#34;</span><span class="p">,</span>
    <span class="c1">// or req.IP() if req is an APIGatewayProxyRequest
</span><span class="c1"></span>    <span class="s">&#34;ipAddress&#34;</span><span class="p">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">RequestContext</span><span class="p">.</span><span class="nx">Identity</span><span class="p">.</span><span class="nx">SourceIP</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">resp</span><span class="p">,</span> <span class="nx">rpcErr</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">RPC</span><span class="p">(</span><span class="s">&#34;aegis_geoip&#34;</span><span class="p">,</span> <span class="nx">rpcPayload</span><span class="p">)</span></code></pre></div>
<p>This interface allows &ldquo;RPC&rdquo; (remote procedure calls) to be handled. In Aegis&rsquo; world, that is to say a Lambda invoking
another Lambda. So the immediate question you should have is, &ldquo;how do you know it&rsquo;s an invocation from another Lambda?&rdquo;
Great question! We don&rsquo;t. Not really anyway. Plus, who&rsquo;s to say it has to be another Lambda invoking it? Technically,
an RPC could come from any program that has access.</p>

<p>The way that this router matches is, like <code>Tasker</code>, through conventions in the JSON message payload itself. In this case,
instead of looking for a <code>_taskName</code> key, it&rsquo;ll be <span class="nowrap"><code>_rpcName</code></span> instead.</p>

<aside class="note-warning">
<i class="fas fa-exclamation-triangle"></i> Could your scheduled task that invokes your Lambda via CloudWatch rule trigger
event also use an RPC handler? Yes, it could, but the idea is to be organized and leverage these conventions so you don't
end up with unpredictable behavior.
</aside>

<p>Like <code>Tasker</code>, <code>RPCRouter</code> also has an optional fall through handler that you can pass to <code>NewRPCRouter()</code> when setting
up the router. The handler function signature is very close to the <code>Tasker</code> handler functions as well.</p>

<p>Unlike most other handlers, this one requires you to return more than just an error. A <code>map[string]interface{}</code> must be
returned as well. What good would the RPC be without something coming back?</p>

<p>Technically speaking, Aegis returns data on your <code>Router</code> handlers as well. It&rsquo;s just done for you automatically because
working with API Gateway responses is predictable. The response struct is what gets returned and Aegis does that for you.
However, in the case of an RPC, it&rsquo;s impossible to know exactly what you are going to return other than a map, because
we know that Lambda works with JSON messages.</p>

<p>Aegis has a top level help function, <code>RPC()</code>, that makes it a bit easier to invoke another Lambda. If you are looking
to invoke one Lambda from another, this should just work for you without any extra effort as the default IAM role on your
Lambdas through Aegis will permit Lambda invocation.</p>

<p>If your needs are more complex than a simple call with a function name and map payload, you will need to use the AWS SDK
to invoke the Lambda instead. Or if you didn&rsquo;t use Aegis to deploy your Lambdas (which would have set up an IAM role),
and you have other special considerations - again, feel free to do your thing. Aegis&rsquo; helpers are not the only way to
go about things.</p>

<aside class="note-info">
<i class="fas fa-info-circle"></i> Don't forget to return a map and an error (or nil) when handling RPCs.
</aside>

    
        

<h1 id="s3-object-router">S3 Object Router</h1>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">s3Router</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">NewS3ObjectRouterForBucket</span><span class="p">(</span><span class="s">&#34;aegis-incoming&#34;</span><span class="p">)</span>
    <span class="c1">// s3Router.Handle(&#34;s3:ObjectCreated:Put&#34;, &#34;*.png&#34;, handleS3Upload)
</span><span class="c1"></span>    <span class="c1">// Put() is a shortcut for the above
</span><span class="c1"></span>    <span class="nx">s3Router</span><span class="p">.</span><span class="nx">Put</span><span class="p">(</span><span class="s">&#34;*.png&#34;</span><span class="p">,</span> <span class="nx">handleS3Upload</span><span class="p">)</span>

    <span class="nx">handlers</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">Handlers</span><span class="p">{</span>
        <span class="nx">S3ObjectRouter</span><span class="p">:</span> <span class="nx">s3Router</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleS3Upload</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">HandlerDependencies</span><span class="p">,</span> <span class="nx">evt</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">S3Event</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// evt will contain bucket name, path, etc.
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span></code></pre></div>
<p>Now here we have an interesting Router. Like the API Gateway Proxy, we have a few things to match on.
It&rsquo;s not just a path, but also a method or operation. In the case of S3 objects, we&rsquo;re talking about
puts and deletes, other such operations, and now also a bucket (or domain if you like).</p>

<p>So the <code>S3ObjectRouter</code> has some convenient methods on it for you to use; <code>Put()</code>, <code>Delete()</code>, <code>Copy()</code>,
and so on. Though you can choose to write it the &ldquo;long&rdquo; way and use <code>Handle()</code> where the first argument
would be the actual S3 object event name.</p>

<p>There are two &ldquo;new&rdquo; methods for this router. <span class="nowrap"><code>NewS3ObjectRouter()</code></span> and
<span class="nowrap"><code>NewS3ObjectRouterForBucket()</code>.</span> Both will take an optional &ldquo;fall through&rdquo;
handler. Both use the same router interface. <span class="nowrap"><code>NewS3ObjectRouterForBucket(&quot;bucket-name&quot;)</code></span>
takes a bucket name and sets it on to the router interface. <span class="nowrap"><code>NewS3ObjectRouter()</code></span>
does not.</p>

<p>This means that you can not only &ldquo;catch all&rdquo; operations and objects, but also all operations and object
for any bucket that&rsquo;s emitting events that trigger your Lambda.</p>

<p>Of course, you could always switch the bucket the router is working with after your have the interface.
For example, assumimg you have <span class="nowrap"><code>r := NewS3ObjectRouter()</code></span>, you could then do
<span class="nowrap"><code>r.Bucket = &quot;my-bucket&quot;</code>.</span></p>

<h2 id="configuring-s3-object-events">Configuring S3 Object Events</h2>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml">bucketTriggers<span class="p">:</span><span class="w">
</span><span class="w">  </span>-<span class="w"> </span>bucket<span class="p">:</span><span class="w"> </span>aegis-incoming<span class="w">
</span><span class="w">    </span>filters<span class="p">:</span><span class="w">
</span><span class="w">      </span>-<span class="w"> </span>name<span class="p">:</span><span class="w"> </span>suffix<span class="w">
</span><span class="w">        </span>value<span class="p">:</span><span class="w"> </span>png<span class="w">
</span><span class="w">      </span><span class="c">#- name: prefix</span><span class="w">
</span><span class="w">      </span><span class="c">#  value: path/</span><span class="w">
</span><span class="w">    </span>eventNames<span class="p">:</span><span class="w">
</span><span class="w">      </span>-<span class="w"> </span>s3<span class="p">:</span>ObjectCreated<span class="p">:</span>*<span class="w">
</span><span class="w">      </span>-<span class="w"> </span>s3<span class="p">:</span>ObjectRemoved<span class="p">:</span>*<span class="w">
</span><span class="w">      </span><span class="c"># ... there&#39;s a few and there&#39;s wildcards, see:</span><span class="w">
</span><span class="w">      </span><span class="c"># https://docs.aws.amazon.com/AmazonS3/latest/dev/NotificationHowTo.html#notification-how-to-event-types-and-destinations</span><span class="w">
</span><span class="w">    </span>disabled<span class="p">:</span><span class="w"> </span><span class="kc">false</span></code></pre></div>
<p>Unlike tasks or RPCs, we can&rsquo;t simply conventionally catch events that might come our way. We actually need to
ensure these events are being sent. The way that happens is through S3 object event triggers. You can set these
up yourself of course (or using your favorite tool like Terraform or CloudFormation). Or, you could leverage
<code>aegis deploy</code> by configuring your <code>aegis.yaml</code> file.</p>

<p>Aegis will look for this configuration each time you call <code>aegis deploy</code> from the CLI. You can also disable the
triggers using the <code>disabled</code> key. Set that to true and deploy again. Re-enable when you&rsquo;re ready again. This way
you don&rsquo;t need to lose anything in your configuration. Aegis is also non-destructive.</p>

<aside class="note-warning">
<i class="fas fa-exclamation-triangle"></i> Note that Aegis will not know to delete your S3 object event triggers.
It can disable them, but it will not remove them. So you will need to manually do so yourself if you no longer want them.
</aside>

<h2 id="event-matching">Event Matching</h2>

<blockquote>
<p>What goes on within Aegis to match an S3 object event</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Bucket</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="o">||</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Bucket</span> <span class="o">==</span> <span class="nx">record</span><span class="p">.</span><span class="nx">S3</span><span class="p">.</span><span class="nx">Bucket</span><span class="p">.</span><span class="nx">Name</span> <span class="p">{</span>
    <span class="c1">// Handlers are registered in a map.
</span><span class="c1"></span>    <span class="c1">// The keys in this map contain your match pattern string.
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">globStr</span><span class="p">,</span> <span class="nx">handler</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span><span class="p">.</span><span class="nx">handlers</span> <span class="p">{</span>
    <span class="nx">g</span> <span class="p">=</span> <span class="nx">glob</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="nx">globStr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">g</span><span class="p">.</span><span class="nx">Match</span><span class="p">(</span><span class="nx">record</span><span class="p">.</span><span class="nx">S3</span><span class="p">.</span><span class="nx">Object</span><span class="p">.</span><span class="nx">Key</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...Goes on to handle the event, calling your handler.
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>Unlike most other routers, S3 object events are matched by glob match. Again, if no match is found, it will use a
fall through handler if you provided one. Note that the bucket name is optional. You could handle objects sent to
any bucket provided its events trigger your Lambda.</p>

<p>So for example, <code>*.png</code> will handle any object that ends with a png extension. Whereas <code>{*.png,*.gif,*.jpg}</code> would handle
any file with those extensions. The package used for glob matching is <a href="https://github.com/gobwas/glob" target="_blank">gobwas/glob</a>.
You can read its documentation for all the options you have available to match, it&rsquo;s rather robust.</p>

<p>A good thing to think about here is the order in which you define your routing rules. It won&rsquo;t really be a concern
for you with other routers, but this one can result in multiple rules matching the same event depending on what
you have set up. The first route match found will be used, calling its handler.</p>

<p>Remember, there are 3 things at play here:</p>

<ul>
<li>The bucket name (if not set, any bucket is a match)</li>
<li>The S3 object event name (if not set, any event is a match)</li>
<li>The S3 object key name (glob match)</li>
</ul>

    
        

<h1 id="ses-router">SES Router</h1>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">sesReceiver</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">NewSESRouter</span><span class="p">()</span>
    <span class="nx">sesReceiver</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&#34;*@ses.serifandsemaphore.io&#34;</span><span class="p">,</span> <span class="nx">handleEmail</span><span class="p">)</span>

    <span class="nx">handlers</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">Handlers</span><span class="p">{</span>
        <span class="nx">SESRouter</span><span class="p">:</span> <span class="nx">sesReceiver</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nx">AegisApp</span> <span class="p">=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">handlers</span><span class="p">)</span>
    <span class="nx">AegisApp</span><span class="p">.</span><span class="nx">Start</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">handleEmail</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">HandlerDependencies</span><span class="p">,</span> <span class="nx">evt</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">SimpleEmailEvent</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">evt</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span></code></pre></div>
<p>The AWS SES (Simple E-mail Service) router, <code>SESRouter</code>, and the ability for a Lambda to receive e-mail
is perhaps one of the coolest things ever. Yes, there is such a thing as serverless e-mail.</p>

    
        

<h1 id="cognito-router">Cognito Router</h1>

<p>There are some AWS Cognito specific events that can be routed as well.</p>

    

        </div>
        <div class="dark-box">
            
        </div>
    </div>
    
</body>
</html>
