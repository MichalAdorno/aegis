<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Routers</title>
    <link href='/aegis/slate/stylesheets/monokai.css' rel="stylesheet" media="screen" />
<link href='/aegis/slate/stylesheets/screen.css' rel="stylesheet" media="screen" />
<link href='/aegis/slate/stylesheets/print.css' rel="stylesheet" media="print" />

    <link href='/aegis/css/menu.css' rel="stylesheet"/>
    <link href='/aegis/css/alerts.css' rel="stylesheet"/>
    <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.0.13/css/solid.css" integrity="sha384-drdlAcijFWubhOfj9OS/gy2Gs34hVhVT90FgJLzrldrLI+7E7lwBxmanEEhKTRTS" crossorigin="anonymous">
<link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.0.13/css/fontawesome.css" integrity="sha384-LDuQaX4rOgqi4rbWCyWj3XVBlgDzuxGy/E6vWN6U7c25/eSJIwyKhy9WgZCHQWXz" crossorigin="anonymous">
    
<script src='/aegis/slate/javascripts/all.js'></script>

    
</head>
<body class="index" data-languages="[ &#34;go&#34; ]">
    <div class="main-nav-wrapper">
        <ul class="main-menu">
            <li class="">
    <a href="/#">Getting Started</a>
</li>


    
    <li class="active">
        <a href="/aegis/routers/" title="Aegis Routers">Routers</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/handler-dependencies/" title="Aegis Dependencies">Dependencies</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/helpers/" title="Aegis Helpers">Helpers</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/cli/" title="Aegis Command Line Interface">CLI</a>
    </li>
    

        </ul>
    </div>
    <a href="#" id="nav-button">
        <span>
        NAV
        <img src='/aegis/slate/images/navbar.png'/>
      </span>
    </a>
    <div class="tocify-wrapper">
        
         <img src='/aegis/images/logo.png' />
        
        <div class="lang-selector">
            
            <a href="#" data-language-name="go">Go</a>
            
        </div>
         
        <aside class="main-menu-sidebar-wrapper">
    <ul class="main-menu-sidebar">
        <li class="">
    <a href="/#">Getting Started</a>
</li>


    
    <li class="active">
        <a href="/aegis/routers/" title="Aegis Routers">Routers</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/handler-dependencies/" title="Aegis Dependencies">Dependencies</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/helpers/" title="Aegis Helpers">Helpers</a>
    </li>
    

    
    <li class="">
        <a href="/aegis/cli/" title="Aegis Command Line Interface">CLI</a>
    </li>
    

    </ul>
</aside>
        
        <div class="search">
            <input type="text" class="search" id="input-search" placeholder='Search This Section'>
        </div>
        <ul class="search-results"></ul>
        
        <div id="toc">
        </div>
         
        
        <ul class="toc-footer">
            
            <li>Documentation Powered by <a href="https://github.com/bep/docuapi" target="_blank">DocuAPI</a></li>
            
            <li>Hugo Theme by <a href="https://github.com/bep" target="_blank">bep</a></li>
            
        </ul>
        
        
    </div>
    <div class="page-wrapper">
        <div class="dark-box"></div>
        <div class="content">
            
    
        <h1 class="toc-ignore">Routers</h1>

<p>First things first. The <a href="https://github.com/aws/aws-lambda-go" target="_blank">AWS Lambda Go package</a>
is used by Aegis. In fact, it&rsquo;s basically required for native Go support in Lambda. I don&rsquo;t think anyone wants
to write a competing package (why??). However, that package is designed to be lightweight. It does not include
a bunch of creature comforts. That&rsquo;s where Aegis routers come in handy.</p>

<p>Above all else, there is a default handler that can be used for any incoming Lambda event. This is called
the <code>DefaultHandler</code>. Aegis routers aim to make life easier without hiding all of the unknowns in life. You
can always handle incoming JSON event messages as maps.</p>

<p>However, there&rsquo;s some very helpful routers to help direct events to your handlers. You&rsquo;re probably looking
to use a framework because you don&rsquo;t want to write all that logic yourself, right?</p>

    
        

<h1 id="api-gateway-router">API Gateway Router</h1>

<blockquote>
<p>This should look familiar if you&rsquo;ve built an HTTP RESTful API in Go before</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="nx">aegis</span> <span class="s">&#34;github.com/tmaiaroto/aegis/framework&#34;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Handle an APIGatewayProxyRequest event with a URL request path Router
</span><span class="c1"></span>    <span class="nx">router</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">NewRouter</span><span class="p">(</span><span class="nx">fallThrough</span><span class="p">)</span>
    <span class="nx">router</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">handleRoot</span><span class="p">)</span>

    <span class="c1">// Register the handler
</span><span class="c1"></span>    <span class="nx">app</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">Handlers</span><span class="p">{</span>
        <span class="nx">Router</span><span class="p">:</span> <span class="nx">router</span><span class="p">,</span>
    <span class="p">})</span>
    <span class="c1">// A blocking call that listens for events
</span><span class="c1"></span>    <span class="nx">app</span><span class="p">.</span><span class="nx">Start</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// fallThrough handles any path that couldn&#39;t be matched to another handler
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">fallThrough</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">HandlerDependencies</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">APIGatewayProxyRequest</span><span class="p">,</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">APIGatewayProxyResponse</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="p">=</span> <span class="mi">404</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// handleRoot is handling GET &#34;/&#34; in this case
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">handleRoot</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">HandlerDependencies</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">APIGatewayProxyRequest</span><span class="p">,</span> <span class="nx">res</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">APIGatewayProxyResponse</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">url</span><span class="p">.</span><span class="nx">Values</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span><span class="s">&#34;event&#34;</span><span class="p">:</span> <span class="nx">req</span><span class="p">})</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span></code></pre></div>
<p>Perhaps the most common event handler is for API Gateway requests. When you think about a router for a web
application, typically handling HTTP requests comes to mind. So the Aegis&rsquo; router for this is simply <code>Router</code>.</p>

<p>While the concept of serverless applications and &ldquo;event handling&rdquo; brings about far more opportunties to &ldquo;route&rdquo;
events, this interface takes the less the descriptive name purely due to familiarity.</p>

<p>The <code>Router</code> works with an <code>ANY</code> method on a wildcard path in API Gateway. Instead of defining paths and methods
to associate with different Lambda functions, Aegis prefers a simpler approach. Though you aren&rsquo;t bound to this,
it certainly makes things a lot easier. However, keep in mind that your Lambda function will be triggered by
API Gateway on literally any request.</p>

<p>Amazon&rsquo;s official <a href="https://github.com/aws/aws-lambda-go" target="_blank">AWS Lambda Go</a> package will
marshal the incoming JSON event message to an API Gateway Proxy Request struct of some sort. Aegis does exactly
the same thing, in fact, it aliases Amazon&rsquo;s struct. The AWS Lambda Go package handles quite a number of different
type of events by converting them into native Go structs. However, you can always handle a plain old map too.</p>

<p>Aegis adds helper functions on to several AWS Lambda Go structs. The goal is to make it feel more familiar for anyone
who has ever written an API in Go before. Also take a look at the <code>res</code> variable in the example code. See how you
can easily set <code>res.StatusCode</code> and return data with the <code>res.JSON()</code> helper function?</p>

<p>Note that every single handled event in Aegis has a return value, which is an <code>error</code>. You&rsquo;ll most often simply
return <code>nil</code>, but if you do return an actual error, it will be returned in the response in this case. Other routers
may have no where to return the error of course, but a <a href="/handler-dependencies/#tracer">tracer</a> might handle it
(for example, AWS X-Ray will handle it).</p>

<p>You could also return your own error with appropriate status code with body content. For example, you could return
a JSON body response that contains the error with a status code of 500. There&rsquo;s even a helper function for this as
well: <code>res.JSONError(500, e)</code> That will return the text of the error in a JSON message.</p>

<h2 id="apigatewayproxyrequest">APIGatewayProxyRequest</h2>

<p>This struct will contain a good bit of information from API Gateway. Most important of all, it will include HTTP
request headers, body, and querystring parameters.</p>

<p>There are a bunch of helpers that you can read about in the <a href="/helpers/#http-proxy-helpers">HTTP (Proxy) Helpers section</a>.
Examples include; <code>IP()</code> which returns the IP address of the client. <code>GetForm</code> which returns form-data from the request.
<code>Cookies()</code> which returns the cookies from the request. These are convenient functions that AWS&rsquo; core Go Lambda package
does not provide, but Aegis&rsquo; aliased version does.</p>

<h2 id="apigatewayproxyresponse">APIGatewayProxyResponse</h2>

<p>This struct is responsible for the response from handled HTTP requests. Ultimately everything in AWS Lambda comes
in as JSON and goes out as JSON. API Gateway will transform the response as needed, but Lambda deals with JSON for
its messaging format.</p>

<p>Therefore, <code>APIGatewayProxyResponse</code> is unmarshaled by the AWS Lambda Go package but, you get to work with a nice
struct that can have functions composed on to it. Again, helpers for this response include things like setting status
codes, body content, headers, and more.</p>

<p>Like <code>APIGatewayProxyRequest</code>, the response struct is also an alias of the AWS Lambda Go package.</p>

<h2 id="fall-through-handler">Fall Through Handler</h2>

<p>When creating a new <code>Router</code> you can define a &ldquo;fall through&rdquo; or &ldquo;catch all&rdquo; handler as seen in the example code snippet.
This will handle any request not matched by your router. A common handler in this case is simple one that does nothing,
but sets a <code>StatusCode</code> of 404.</p>

<aside class="note-warning">
    Some routers in Aegis have optional fall through handlers. The API Gateway Router's fall through is not optional.
</aside>

<h2 id="middleware">Middleware</h2>

<p>Aegis&rsquo; router also supports middleware. Standard Go http library middleware at that.</p>

    
        

<h1 id="tasker">Tasker</h1>

<p>The <code>Tasker</code> is an interface to route scheduled jobs or &ldquo;tasks&rdquo; that your Lambda may perform. This works
in conjunction with CloudWatch Rules. So you&rsquo;ll need to have events setn to your Lambda from CloudWatch.</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;schedule&#34;</span><span class="p">:</span> <span class="s2">&#34;rate(1 minute)&#34;</span><span class="p">,</span>
    <span class="nt">&#34;disabled&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nt">&#34;input&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;_taskName&#34;</span><span class="p">:</span> <span class="s2">&#34;test&#34;</span><span class="p">,</span>
        <span class="nt">&#34;foo&#34;</span><span class="p">:</span> <span class="s2">&#34;bar&#34;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>Aegis makes this easy to do through a conventional approach. You need not configure CloudWatch events
manually (though you can of course). You also don&rsquo;t add them to your <code>aegis.yaml</code> or anything like that.
It&rsquo;s much easier; you&rsquo;ll just add a <code>tasks</code> directory at the root of your source code where you run
<code>aegis deploy</code>. Within this directory, you can include JSON files for each scheduled task you&rsquo;d like
to set up.</p>

<h3 id="task-json-definition-format">Task JSON Definition Format</h3>

<p>The first key being <code>schedule</code> which takes a CloudWatch Event Rule expression (ie. &ldquo;rate&rdquo; or crontab format).
The optional <code>disabled</code> key in your JSON task definition can disable your CloudWatch rule so you don&rsquo;t
need to delete it just to turn it off for a while.</p>

<p>Then you have the <code>input</code> key which contains an object that has your event message. This can be anything
you want. It comes in to your handler as a <code>map[string]interface{}</code> and is &ldquo;static JSON&rdquo; in terms of
the CloudWatch Rule configuration.</p>

<p>There is a conventional <code>_taskName</code> key in your payload that you need to be aware of. This is what gets
matched by the <code>Tasker</code> in order to delegate to your handlers.</p>

<aside class="info">
Note that tasks are routed by exact match.
</aside>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tasker</span> <span class="o">:=</span> <span class="nx">aegis</span><span class="p">.</span><span class="nx">NewTasker</span><span class="p">(</span><span class="nx">taskerFallThrough</span><span class="p">)</span>
<span class="nx">tasker</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="nx">handleTestTask</span><span class="p">)</span></code></pre></div>
<blockquote>
<p>The handler should look familiar, excpet that the event is simply a map</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Example task handler
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">handleTestTask</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">aegis</span><span class="p">.</span><span class="nx">HandlerDependencies</span><span class="p">,</span> <span class="nx">evt</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&#34;Handling task!&#34;</span><span class="p">,</span> <span class="nx">evt</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span></code></pre></div>
<h3 id="handling-tasks">Handling Tasks</h3>

<p>Like the API Gateway Proxy Request <code>Router</code>, <code>Tasker</code> has a &ldquo;fall through&rdquo; or &ldquo;catch all&rdquo; as well.
It&rsquo;s function signature is no different than any other task handler. This fall through handler is also
optional. You can call <code>aegis.NewTasker()</code> to use just as well. In that case, if your configured <code>Tasker</code>
does not match any task names, it will not route those events and they won&rsquo;t be handled.</p>

    
        

<h1 id="rpc-router">RPC Router</h1>

<p>This interface allows &ldquo;RPC&rdquo; (remote procedure calls) to be handled. In Aegis&rsquo; world, that is to say a Lambda invoking
another Lambda.</p>

    
        

<h1 id="s3-object-router">S3 Object Router</h1>

<p>This interface will route S3 object events to handlers.</p>

    
        

<h1 id="ses-router">SES Router</h1>

<p>This interface will route AWS SES (simple e-mail service) events to the appropriate handlers. This can
be based on an e-mail address match exact or in part.</p>

    
        

<h1 id="cognito-router">Cognito Router</h1>

<p>There are some AWS Cognito specific events that can be routed as well.</p>

    

        </div>
        <div class="dark-box">
            
            <div class="lang-selector">
                
                <a href="#" data-language-name="go">Go</a>
                
            </div>
            
        </div>
    </div>
    
</body>
</html>
